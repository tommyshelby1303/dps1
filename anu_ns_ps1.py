# -*- coding: utf-8 -*-
"""anu_NS_PS1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_MEQ0HzQqhh1XCylgwDeq1aG1L7RZcTb

Q1
"""

import networkx as nx
import matplotlib.pyplot as plt

# Function to generate and visualize an Erdős-Rényi network
def generate_erdos_renyi(N, avg_degree, title):
    # Calculate the linking probability p
    p = avg_degree / (N - 1)

    # Generate the Erdős-Rényi network
    G = nx.erdos_renyi_graph(N, p)

    # Draw the network
    plt.figure(figsize=(6, 6))
    nx.draw(G, node_size=20, node_color='blue', edge_color='gray', with_labels=False)
    plt.title(title)
    plt.show()

# Parameters
N = 500  # Number of nodes

# (a) Average degree 〈k〉 = 0.8
generate_erdos_renyi(N, avg_degree=0, title="Erdős-Rényi Network (N=500, <k>=0)")


# (a) Average degree 〈k〉 = 0.8
generate_erdos_renyi(N, avg_degree=0.8, title="Erdős-Rényi Network (N=500, <k>=0.8)")

# (b) Average degree 〈k〉 = 1
generate_erdos_renyi(N, avg_degree=1, title="Erdős-Rényi Network (N=500, <k>=1)")

# (c) Average degree 〈k〉 = 8
generate_erdos_renyi(N, avg_degree=8, title="Erdős-Rényi Network (N=500, <k>=8)")

"""Q2"""

import random

N=random.randint(1,10)

node_clr=['blue']*N + ['red']*N
random.shuffle(node_clr)

print(N)
print(node_clr)

from re import A
import numpy as np

Adj_mat=np.zeros((2*N,2*N))
p=random.random()
q=random.random()

for i in range(2*N):
  for j in range(i+1,2*N):
    if node_clr[i]==node_clr[j]:
      if random.random()<=p:
        Adj_mat[i][j]=1
    else:
      if random.random()<=q:
        Adj_mat[i][j]=1

for i in range(2*N):
  for j in range(i):
    Adj_mat[i][j]=Adj_mat[j][i]

print(Adj_mat)

G=nx.from_numpy_array(Adj_mat)
plt.figure(figsize=(3,3))
nx.draw(G, node_size=50, node_color=node_clr, edge_color='gray', with_labels=False)
plt.show()

print("p=",p,"q=",q)
if p>q:
  print("Network is snobbish")

"""If q=0:"""

from re import A
import numpy as np

Adj_mat0=np.zeros((2*N,2*N))
p=random.random()
q=0

for i in range(2*N):
  for j in range(i+1,2*N):
    if node_clr[i]==node_clr[j]:
      if random.random()<=p:
        Adj_mat0[i][j]=1
    else:
      if random.random()<=q:
        Adj_mat0[i][j]=1

for i in range(2*N):
  for j in range(i):
    Adj_mat0[i][j]=Adj_mat0[j][i]

#print(Adj_mat)
G0=nx.from_numpy_array(Adj_mat0)
plt.figure(figsize=(3,3))
nx.draw(G0, node_size=50, node_color=node_clr, edge_color='gray', with_labels=False)
plt.show()

"""(i) Average degree of blue network and average degree of full network"""

tot_deg=sum([list(row).count(1) for row in Adj_mat])
avg_degree=tot_deg/len(Adj_mat)
print("For whole network: <K> = ",avg_degree)

blue_ids=[]
for i in range(2*N):
  if node_clr[i]=='blue':
    blue_ids.append(i)

blue_deg=sum([list(row).count(1) for row in Adj_mat[blue_ids][:,blue_ids]])
avg_degree_blue=blue_deg/len(blue_ids)
print("For blue network: <K> = ",avg_degree_blue)

blue_ids

Adj_mat[blue_ids][:,blue_ids].shape

"""(ii) Minimal p and q for network to be connected"""

def draw_graph(N,p,q):
  node_clr=['blue']*N + ['red']*N
  random.shuffle(node_clr)
  Adj_mat=np.zeros((2*N,2*N))
  for i in range(2*N):
    for j in range(i+1,2*N):
      if node_clr[i]==node_clr[j]:
        if random.random()<=p:
          Adj_mat[i][j]=1
      else:
        if random.random()<=q:
          Adj_mat[i][j]=1

  for i in range(2*N):
    for j in range(i):
      Adj_mat[i][j]=Adj_mat[j][i]

  G=nx.from_numpy_array(Adj_mat)
  '''plt.figure(figsize=(3,3))
  nx.draw(G, node_size=50, node_color=node_clr, edge_color='gray', with_labels=False)
  plt.title("p="+str(p)+", q="+str(q))
  plt.show()'''

  return G

def is_connected(G):
  return nx.is_connected(G)

#draw graph 100 times with given p,q and check if graph results in a single connected component at least 90% of the time
def check_pq(N,p,q):

  con_cnt=0
  for i in range(100):
    G=draw_graph(N,p,q)
    if is_connected(G):
      con_cnt+=1
  if con_cnt>=90:
    return True
  else:
    return False

def find_min_p_q(N):
    """
    Finds the minimum values of p and q for which the network has a single connected component.
    """
    p_min = 0  # Minimum p to ensure connectivity within each sub-network
    q_min = 0
    p = p_min
    q = q_min

    # Gradually increase q until the network is connected
    while True:

        if check_pq(N,p,q):
          break
        p += 0.01

        if check_pq(N,p,q):
          break
        q += 0.01  # Increment q by small steps

    return p, q

p,q=find_min_p_q(6)

print("p=",p,"q=",q)

G=draw_graph(N,p,q)
plt.figure(figsize=(3,3))
nx.draw(G, node_size=50, node_color=node_clr, edge_color='gray', with_labels=False)
plt.title("p="+str(p)+", q="+str(q))
plt.show()

"""(iii) Small world property"""

p=0.9
q=0.01
N=200
G=draw_graph(N,p,q)

avg_cluster=nx.average_clustering(G)
print("Average clustering coefficient: ",avg_cluster)

if nx.is_connected(G):
  avg_shortest_path=nx.average_shortest_path_length(G)
  print("Average shortest path length: ",avg_shortest_path)
else:
  print("Network is not connected")

"""High clustering coefficient and short average path length shows small world property

Q3
"""

def draw_graph(N,p,q,f):
  node_clr=['blue']*N + ['red']*N
  purple_nodes=random.sample(range(2*N),int(f*2*N))
  for i in purple_nodes:
    node_clr[i]='purple'
  random.shuffle(node_clr)

  Adj_mat=np.zeros((2*N,2*N))
  for i in range(2*N):
    for j in range(i+1,2*N):
      if (node_clr[i]=='blue' and node_clr[j]=='blue') or (node_clr[i]=='red' and node_clr[j]=='red'):
        if random.random()<=p:
          Adj_mat[i][j]=1
      elif node_clr[i]=='purple' and (node_clr[j]=='red' or node_clr[j]=='blue'):
        if random.random()<=p:
          Adj_mat[i][j]=1

  for i in range(2*N):
    for j in range(i):
      Adj_mat[i][j]=Adj_mat[j][i]

  G=nx.from_numpy_array(Adj_mat)
  plt.figure(figsize=(6,6))
  nx.draw(G, node_size=50, node_color=node_clr, edge_color='gray', with_labels=False)
  plt.title("p="+str(p)+", q="+str(q))
  plt.show()

  return G,node_clr

N=25
p=0.5
q=0
f=0.1
G,node_clr=draw_graph(N,p,q,f)

"""HW1"""

import math
import numpy as np
from scipy.optimize import fsolve

def expected_links(N, p):
    return p * N * (N - 1) / 2

def critical_probability(N):
    return 1 / N

def network_regime(N, p):
    pc = critical_probability(N)
    if p < pc:
        return "Subcritical"
    elif p==pc:
        return 'Critical'
    elif p > pc and p<(math.log(N)/N):
        return "Supercritical"
    else:
        return "Connected"

def solve_Ncr(p):
    def equation(N):
        return p - math.log(N) / N
    return fsolve(equation, 1000)[0]

def average_degree(N, p):
    return p * (N - 1)

def average_distance(N, k_avg):
    return math.log(N) / math.log(k_avg)

def degree_distribution(k, lambda_val):
    return (math.exp(-lambda_val) * lambda_val**k) / math.factorial(k)

# Given parameters
N = 3000
p = 1e-3

# 1. Expected number of links
L_avg = expected_links(N, p)
print(f"1. Expected number of links: {L_avg:.2f}")
print()

# 2. Network regime
regime = network_regime(N, p)
print(f"2. Network regime: {regime}")
print()

# 3. Critical probability
pc = critical_probability(N)
print(f"3. Critical probability: {pc:.6f}")
print()

# 4. Number of nodes for one component
N_cr = solve_Ncr(p)
print(f"4. Number of nodes for one component: {N_cr:.2f}")
print()

# 5. Average degree and distance for the network in (d)
k_cr_avg = average_degree(N_cr, p)
d_avg = average_distance(N_cr, k_cr_avg)
print(f"5. For the network in (d):")
print(f"   \tAverage degree: {k_cr_avg:.2f}")
print(f"   \tAverage distance: {d_avg:.2f}")
print()

# 6. Degree distribution
lambda_val = average_degree(N, p)
k_values = range(20)  # Calculate for k = 0 to 19
pk_values = [degree_distribution(k, lambda_val) for k in k_values]

print("6. Degree distribution:")
for k, pk in zip(k_values, pk_values):
    print(f"   P({k}) = {pk:.6f}")

"""HW2: Circular network"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Function to create a circular nearest-neighbor network
def circular_neighbor_network(N, m):
    G = nx.Graph()

    # Add N nodes
    G.add_nodes_from(range(N))

    # Add edges to each node's 2m neighbors
    for i in range(N):
        for j in range(1, m + 1):

            G.add_edge(i, (i + j) % N)  # Neighbors on one side
            G.add_edge(i, (i - j) % N)  # Neighbors on the other side

    return G

# Function to calculate average clustering coefficient and average shortest path
def calculate_metrics(G):
    # Average clustering coefficient
    avg_clustering = nx.average_clustering(G)

    # Average shortest path length
    if nx.is_connected(G):
        avg_shortest_path = nx.average_shortest_path_length(G)
    else:
        avg_shortest_path = np.inf  # Infinite if the graph is disconnected

    return avg_clustering, avg_shortest_path

# Visualize the network
def visualize_network(G, title):
    pos = nx.circular_layout(G)
    plt.figure(figsize=(6, 6))
    nx.draw(G, pos, node_size=100, node_color='blue', edge_color='gray', with_labels=False)
    plt.title(title)
    plt.show()

# Parameters
N = 20  # Number of nodes
m = 4   # Number of neighbors on each side

# Create the network
G = circular_neighbor_network(N, m)

# Visualize the network
visualize_network(G, f'Circular Neighbor Network (N={N}, m={m})')

# Calculate metrics
avg_clustering, avg_shortest_path = calculate_metrics(G)

# Print results
print(f"Average Clustering Coefficient 〈C〉: {avg_clustering:.4f}")
print(f"Average Shortest Path Length 〈d〉: {avg_shortest_path:.4f}")

# Let's try for N much larger, say N = 1000 and m = 10
N_large = 1000
m_large = 4

# Create the large network
G_large = circular_neighbor_network(N_large, m_large)

# Calculate metrics for the large network
avg_clustering_large, avg_shortest_path_large = calculate_metrics(G_large)

# Print results for large N
print(f"\nFor N ≫ 1 (N={N_large}, m={m_large}):")
print(f"Average Clustering Coefficient 〈C〉: {avg_clustering_large:.4f}")
print(f"Average Shortest Path Length 〈d〉: {avg_shortest_path_large:.4f}")

